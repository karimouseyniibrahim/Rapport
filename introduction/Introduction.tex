%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%									Chapitre Introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction Générale}
\section{Introduction}
Depuis la découverte de l’informatique, de nombreuses activités de la vie courante ont été simplifiés. Aujourd’hui, on se sert de l’informatique pour traiter des informations en utilisant des logiciels et des réseaux informatiques. Et pour ce faire, ce système est devenu maniable presque dans tout le domaine de la vie courante (L'alimentation, L'eau, L’entretien de la maison, La construction, Le bénévolat, Le jardinage, Les achats, Les loisirs, avionique, ferroviaire, nucléaire, médicale, etc.).

Les systèmes(avionique, ferroviaire, nucléaire, médicale, etc.) sont caractérisés par leurs aspects critiques, complexes et réactifs, et opèrent comme des programmes très concurrents avec des milliers d’entités s’exécutant en parallèle et communiquant sous différentes conditions environnementales. L’analyse de ces systèmes est particulièrement difficile, car un mauvais fonctionnement du système aurait un impact important sur la sécurité ou la vie des personnes, des entreprises ou des biens. En fait, plusieurs catastrophiques sont dues à des erreurs de spécification, a titre d'exemple, l'échec du vol inaugural de la fusée Ariane 5 en 1996 a pour origine  plusieurs erreurs de spécification du logiciel de commande, et notamment de son système de tolérance aux faute \cite{arian5}, en 2002, autre exemple dramatique, celui d’un missile anti-missile Patriot déployé en Arabie Saoudite, que le système de surveillance a refusé de lancer sur un missile ennemi \cite{patriot}, le bug de l'an 2000 est un exemple, causé par une erreur de vérification sur les dates \cite{bug2000}.

Les méthodes formelles permettent de parvenir à une preuve, au sens mathématique, le bon fonctionnement du système. Ils
se basent sur la description du système avec un langage formel (i.e. non ambigu) muni d’une sémantique précise, une fois le système décrit, ces méthodes peuvent prouver la correction du modèle en assurant que le comportement du système développé satisfait tous les besoins désirés et les propriétés spécifiées. Cette vérification peut prendre plusieurs formes, dont l’approche basée sur la preuve de théorèmes permet de vérifier de manière paramétrique un système qui est décrit sous la forme d’axiomes \cite{Rushby2001}, et l’approche basée sur le model checking, il permet de confronter un système (sa description opérationnelle) à ses spécifications (les propriétés que l’on attend de lui), de détecter automatiquement des erreurs dans le processus de conception \cite{Clark1999}.

Les techniques des méthodes formelles sont automatisable dès lors que l’on possède un modèle formel et des propriétés à vérifier. La puissance de cette méthode réside dans la précision de la réponse obtenue (la propriété est vérifiée ou non),  aussi elle fournit un contre-exemple en cas d’erreur dans le modèle (le système ne vérifie pas la propriété spécifiée) permettant ainsi de corriger le problème.

\section{Problématique}
Du fait de la taille de l'espace d'états de certains systèmes spécifier, il est en général impossible de les explorer dans un temps raisonnable ou il se heurte au problème de l'explosion combinatoire du nombre d'états à explorer. Ce problème est retardé par la distribution de l'espace d'états sur un réseau de machines connectées afin de tirer profit de la quantité de mémoire et de la puissance de calcul disponibles.

Dans l’implémentation distribuée, le model checking souffre un problème majeur engendré par la distribution de l'espace d'états du systèmes spécifier car il est impossible de connaître à l’avance le temps de calcul que prendra l’exploration de l'espace d'états. L'espace d'états est distribué de sorte que des machines pourraient avoir des états trop faciles à calculer. Il est donc difficile de s’assurer que toutes les machines sont utilisées au maximum de
leur capacité et donc on ne peut pas arriver à une accélération linéaire.

Notre objectif dans la génération distribuée est d’établir un compromis entre l’équilibrage de la charge entre les différentes machines et la minimisation des coûts de communication. Cependant, l’expérience pratique a montré qu’aucun de ces deux objectifs pris séparément ne peut suffire pour avoir une bonne distribution de l’espace des états.

\section{Contributions}

Dans l’implémentation distribuée, les solutions proposées dans la littérature travaillent en amont c-à-d avant
ou au moment de la génération de l’espace d’états en utilisant des fonctions de partitions. La philosophie de ces méthodes visent à aboutir à la meilleure distribution sans savoir au préalable les applications qui vont exploiter le graphe distribué par la suite. Cependant ces applications sont de nature différentes, et peuvent dans le cas échéant être inconnues. Suite à cela, nous proposons une nouvelle approche de distribution en avale de l'espace d'états basée sur le comportement des applications. L’approche proposée vise à analyser le comportement d’un système donné en générant son espace d’état et en extrayant les informations pertinentes sur les états et leurs connexions (transitions internes et externes). Ensuite, redistribuer l’espace d’états selon certaines heuristiques afin d’optimiser les performances du système. Cela est fait en définissant une bonne localité pour l'état comme celle qui optimise à la
fois l’équilibre de charge et la quantité de communication entre les machines. L’intuition derrière cette approche permet à une application d'optimiser ses comportements en cumulant ses expériences d’exécution, ainsi grâce à l'utilisation des base de donnée orienté graphe, les prochaines exécutions future de l’application seront fait à partir des améliorations gagnés précédemment.

\section{Plan du document}
Conformément à ce qui vient d’être exposé dans notre travail de recherche, il se décompose en deux parties :

\paragraph{La première partie} est consacrée à la présentation du domaine de notre étude et les
principaux concepts utilisés dans ce travail. Elle contient deux chapitres.
\begin{description}
	\item[Le premier chapitre] aborde quelques notions de base sur l’optimisation combinatoire ainsi que de la théorie de graphes. Introduit les notion de distribution de l'espace d'états et pressente les implémentations distribuées du model checking proposées dans la littérature.
	\item [Le deuxième chapitre ] est consacré à la présentation du contexte général de notre travail, introduit les réseaux de Petri ainsi que les systèmes de transitions étiquetées et les structures de Kripke, ensuite met l’accent sur	la technique de model checking en pressentant les concepts de la logique temporaire arborescente. Par la suite, le model cheching distribué est présenté.
\end{description}

\paragraph{La seconde partie} est dédiée aux contributions de notre étude, Elle contient uns chapitre.
 Nous présentons notre approche l’algorithme de génération parallèle d'une structure de Kripke distribué à partir d'un réseau de Petri. Ensuite, nous décrivons notre approche de distribution en avale de l'espace d'états par le comportement des applications. Nous finirons avec la présentation d'un système de stockage dédiée aux espace d'états et l’implémentation de cette approche ainsi que l’interprétation des résultats obtenus.
 \\\\
 
 
Enfin, la conclusion générale qui englobe l’aboutissement des résultats obtenus  ainsi que les perspectives à développer dans l’avenir.  

