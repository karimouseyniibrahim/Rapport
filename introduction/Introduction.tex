%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%									Chapitre Introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\addcontentsline{toc}{part}{Introduction Générale}
\markboth{Introduction Générale}{}
\chapter*{Introduction Générale}

\section*{Introduction}
Depuis la découverte de l’informatique, de nombreuses activités de la vie courante ont été simplifiées. Aujourd'hui, on se sert de l’informatique pour traiter des informations en utilisant des logiciels et des réseaux informatiques. Et pour ce faire, ce système est devenu maniable presque dans tout les domaines de la vie courante (l'alimentation, l'eau, l’entretien de la maison, la construction, le bénévolat, le jardinage, les achats, les loisirs, l'avionique, le ferroviaire, le nucléaire, le médicale, etc.).

Certains de ces systèmes, tels que les systèmes avioniques, ferroviaires, nucléaires et médicales, sont caractérisés par leurs aspects critiques, complexes et réactifs, et opèrent comme des programmes très concurrents avec des milliers d’entités s’exécutant en parallèle et communiquant sous différentes contraintes environnementales. L’analyse de ces systèmes est particulièrement difficile, car un mauvais fonctionnement du système aurait un impact important sur la sécurité ou la vie des personnes, des entreprises ou des biens. En fait, plusieurs catastrophes sont dues à des erreurs de spécification, à titre d'exemple, l'échec du vol inaugural de la fusée Ariane 5 en 1996 a pour origine  plusieurs erreurs de spécification du logiciel de commande, et notamment de son système de tolérance aux fautes \citep{arian5}; En 2002, un autre exemple dramatique a eu lieu, il s'agit du missile anti-missile Patriote déployé en Arabie Saoudite, que le système de surveillance a refusé de lancer sur un missile ennemi \citep{patriot}; Le bug de l'an 2000 est un exemple, causé par une erreur de specification sur les dates \citep{bug2000}.

Les méthodes formelles permettent de parvenir à une preuve, au sens mathématique, du bon fonctionnement du système. Elles se basent sur la description du système avec un langage formel (i.e. non ambigu) muni d’une sémantique précise. Une fois le système décrit, ces méthodes peuvent prouver la correction du modèle en assurant que le comportement du système développé satisfait tous les besoins désirés et les propriétés spécifiées. Cette vérification peut prendre plusieurs formes, dont l’approche basée sur la preuve de théorèmes permet de vérifier de manière paramétrique un système qui est décrit sous la forme d’axiomes \citep{Rushby2001}, et l’approche basée sur le model checking, permet de confronter un système (sa description opérationnelle) à ses spécifications (les propriétés que l’on attend de lui), de détecter automatiquement des erreurs dans le processus de conception \citep{Clarke1999}.

Les techniques des méthodes formelles sont automatisables dès lors que l’on possède un modèle formel et des propriétés à vérifier. La puissance de cette méthode réside dans la précision de la réponse obtenue (la propriété est vérifiée ou non), elle fournit aussi un contre-exemple en cas de non satisfiabilité de la propriété dans le modèle (le système ne vérifie pas la propriété spécifiée) permettant ainsi de corriger la source de l'erreur dans le système.

\section*{Problématique}
Du fait de la taille de l'espace d'états de certains systèmes spécifiés, il est en général impossible de les explorer dans un temps raisonnable, on se heurte au problème de l'explosion combinatoire du nombre d'états à explorer. Ce problème est retardé par la distribution de l'espace d'états sur un réseau de machines connectées afin de tirer profit de la quantité de mémoire et de la puissance de calcul disponibles.

Dans l’implémentation distribuée, le model checking souffre d'un problème majeur engendré par la distribution de l'espace d'états du systèmes spécifié car il est impossible de connaître à l’avance le temps de calcul que prendra l’exploration de l'espace d'états. L'espace d'états est distribué de sorte que des machines pourraient avoir des états trop faciles à calculer. Il est donc difficile de s’assurer que toutes les machines sont utilisées au maximum de leur capacité et donc on ne peut pas arriver à une accélération linéaire.

Notre objectif réside dans la génération distribuée de l'espace d'états, c'est d’établir un compromis entre l’équilibrage de charge des différentes machines et la minimisation du taux de communications. Cependant, l’expérience pratique a montré que chacun de ces deux objectifs pris séparément ne peut suffire pour avoir une bonne distribution de l’espace des états. Plus précisément, ces deux objectifs sont contradictoires dans le sens où l'amélioration de l'un se fera au détriment de l'autre.

\section*{Contributions}

Dans l’implémentation distribuée, les solutions proposées dans la littérature travaillent en amont c-à-d avant ou au moment de la génération de l’espace d’états en utilisant des fonctions de partitions. La philosophie de ces méthodes visent à aboutir à la meilleure distribution sans connaitre au préalable les applications qui vont exploiter le graphe distribué par la suite. Cependant ces applications sont de nature différentes, et peuvent dans le cas échéant être inconnues. Suite à cela, une nouvelle approche de distribution comportementale a été proposée dans la thèse de Bensetira basée sur des heuristiques en fonction des transitions \citep{BENSETIRA2017}. Ainsi nous proposons une nouvelle approche de distribution en avale de l'espace d'états basée la théorie de jeux et l'analyse des états. L’approche proposée vise à analyser l'espace d’états tout en extrayant les informations pertinentes sur les états. Ensuite, redistribuer les états suite à leurs pertinences soit migrés définitivement soit dupliqués sur d’autres machines, afin de minimiser le nombre de communications entre les machines. Cela est fait grâce à une stratégie comportementale de la théorie de jeux au quelle les machines cherchent à optimiser leur taux de communications tout en maintenant l'équilibrage de charge entre les machines à l’aide de seuils prédéfinis pour chaque machine. Ceci permet à une application d'optimiser ses comportements en cumulant ses expériences d’exécutions, ainsi grâce à l'utilisation des bases de données orientés graphes, les prochaines exécutions de l’application seront fait à partir des améliorations gagnées précédemment.

\section*{Plan du document}
Conformément à ce qui vient d’être exposé, le manuscrit se décompose en deux parties :

\paragraph{La première partie} est consacrée à la présentation du domaine de notre étude et les
principaux concepts utilisés dans ce travail. Elle contient deux chapitres.
\begin{description}
	\item[Le premier chapitre] aborde quelques notions de base sur l’optimisation combinatoire, de la théorie des graphes ainsi que de la théorie des jeux. Une introduction sur la distribution de l'espace d'états et pressente les implémentations distribuées de l'espace d'états basé sur le model checking proposées dans la littérature.
	\item [Le deuxième chapitre ] est consacré à la présentation du contexte général de notre travail, il rappelle quelques notions sur les réseaux de Petri et les systèmes de transitions étiquetées ainsi que les structures de Kripke. Ensuite, il met l’accent sur la technique du model checking en présentant les concepts de la logique temporelle arborescente, pour présenter par la suite le model cheching distribué.
\end{description}

\paragraph{La seconde partie} est dédiée aux contributions de notre projet, elle contient un chapitre.
 Nous présentons l'approche de génération parallèle d'une structure de Kripke distribuée à partir d'un réseau de Petri. Ensuite, nous décrivons notre approche de distribution en avale de l'espace d'états guidée par le model checking distribué. Nous finirons avec la présentation d'un système de stockage dédiée aux espaces d'états ainsi que les outils utilisés pour l'implémentation de cette approche et l’interprétation des résultats obtenus.
 \\\\
 
 
Enfin, la conclusion générale qui englobe l’aboutissement des résultats obtenus  ainsi que les perspectives à développer dans l’avenir.  

